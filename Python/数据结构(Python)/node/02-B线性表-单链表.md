# 链表
链表有四个形态：单链表、双链表、循环链表、静态链表

**特点**：不要求逻辑上相邻的元素在物理位置上也相邻

链表的元素离散分布在存储空间中，所以单链表是非随机存取的存储结构，即不能直接找到某个特定的结点

## 单链表
单链表只有一个指针域，所以只能从头结点开始依次向后遍历，所以访问后继结点的时间复杂度为 $O(1)$ ，访问前驱结点的时间复杂度为 $O(n)$

单链表的创建方式分为两种：头插法和尾插法。
- 头插法：新结点插入到链表头部，但会让待插入数据的顺序与原顺序相反
- 尾插法：新结点插入到链表尾部，与待插入数据的顺序与原顺序相同，但会增加一个指针指向当前结点
**单链表的节点描述：**
```python
class LNode{
    def __init__(self,data = Node):
        self.data = data                # 数据域，用于存放数据
        self.next = None                # 指针域，用于指向下一个节点
}
```
**头节点描述：**
```python
class LinkList{
    def __init__(self):
        self.head = LinkNode()          # 头结点head
        self.head.next = Node           # 头结点的指针域指向第一个节点，即首元结点
}
```
**单链表头插法**
```python
def CreateListHeadInsert(self,a):
    for i in range(len(a)):             # 遍历待插入的列表a中的每一个元素
        s = LNode(a[i])                 # 将该元素转为Lnode结点并赋值给s
        s.next = self.head.next         # 让s的指针域指向首元结点
        self.head.next = s              # 让头结点的指针域指向s
```
**单链表尾插法**
```python
def CreateListTailInsert(self,a):
    p = self.head                       # 将头结点赋值给指针p，作为当前结点的引用
    for i in range(len(a)):             # 遍历待插入列表a中的每一个元素
        s = LNode(a[i])                 # 将该元素转为Lnode结点并赋值给s
        p.next = s                      # 将当前结点p的指针域指向结点s，实现了将新结点插入到链表的尾部
        p = s                           # 将当前结点p移动到结点s，准备进行下一次插入操作
    p.next = None                       # 将尾结点的指针域置为None，表示单链表的尾部
```
**单链表遍历显示**
```python
def display(self):
    p = self.head
    while p.next != None:               # 遍历链表，如果发现当前结点的指针域为空，则表示遍历完成
        print(p.next.data,end = ' ')    # 输出
        p = p.next                      # 将当前结点p移动到下一个节点
    print()                             # 全部输出完成后换行
```
**单链表获取链表data长度**
```python
def getLength(self):
    p = self.head                       # 当前结点p
    length = 0                          # 长度设置为0
    while p.next != None:               # 遍历链表，如果发现当前结点的指针域为空，则表示遍历完成
        length += 1                     # 没遍历完就增加一个长度
        p = p.next                      # 将当前结点p移动到下一个节点
    return length                       # 遍历完成后返回最终的链表长度
```
**单链表尾插数据**
```python
def append(self,data):
    s = LNode(data)                     # 将待插入的数据转为LNode结点，并用s指向它
    p = self.head                       # 设置当前节点指针p
    while p.next != None:               # 遍历链表，如果发现当前结点的指针域为空，则表示遍历完成
        p = p.next                      # 没遍历完就将当前结点p移动到下一个节点
    p.next = s                          # 遍历完成后就将最后一个结点的指针域指向新结点s
```
**单链表通过结点号获取整个结点**
```python
def getNode(self,index):
    p = self.head                       # 设置当前节点指针p
    count = -1                          # 设置计数器，从0开始
    while p != None and count < index:  # 遍历链表，保证遍历完成 或者 找到指定结点
        count += 1                      # 没遍历完就增加计数器
        p = p.next                      # 将当前结点p移动到下一个节点
    return p                            # 满足条件后返回结点
```
**单链表通过结点号获取data**
```python
def getElement(self,index):
    assert 0 <= index < self.getLength()# 断言，保证查询的结点号在链表长度范围内
    p = self.getNode(index)             # 获取结点号的整个结点
    assert p != None                    # 断言，保证结点存在
    return p.data                       # 满足条件后返回结点的data
```
**单链表通过结点号设置data**
```python
def setElement(self,index,data):
    assert 0 <= index < self.getLength()# 断言，保证查询的结点号在链表长度范围内
    p = self.getNode(index)             # 获取结点号的整个结点
    assert p != None                    # 断言，保证结点存在
    p.data = data                       # 满足条件后将该节点的data设置为待更改的值
```
**单链表通过data获取结点号**
```python
def getIndex(self,data):
    p = self.head                       # 设置当前节点指针p
    count = 0                           # 设置计数器，从0开始
    while p.next != None:               # 遍历链表，如果发现当前结点的指针域为空，则表示遍历完成
        if p.data != data:              # 如果当前结点的data与待查data不同
            p = p.next                  # 将当前结点p移动到下一个节点
            count += 1                  # 并将计数器加一
        else:
            return count                # 如果当前结点的data与待查data相同，则返回当前结点的结点号
    return None                         # 遍历完成后没有找到相同的data，则返回None
```
**单链表在指定结点插入数据**
```python
def insert(self,index,data):
    assert 0 <= index <= self.getLength()
    s = LNode(data)
    p = self.getNode(index-1)
    assert p != None
    s.next = p.next
    p.next = s
```
**单链表在指定结点删除数据**
```python
def delete(self,index):
    assert 0 <= index < self.getLength()
    p = self.getNode(index-1)
    assert p != None and p.next != None
    p.next = p.next.next
```