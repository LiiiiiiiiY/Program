# 线性表
具有相同数据类型的n个数据元素的有限序列，每个数据元素都有唯一的序号
> 相同数据类型代表：每个数据元素所占的空间相同

线性表的两个基本特征：1、有前后关系，2、有限个数据元素

## 线性表的顺序存储结构
特点：1、逻辑上相邻的元素在物理位置上也相邻。2、随机存取，$O(n)$
缺点：在插入或删除操作时平均需要移动一半的元素，效率低

#### 顺序表定义
```python
class SqlList:
    def __init__(self):                     # 构造方法
        self.initcapacity = 5               # 初始化容量
        self.capacity = self.initcapacity   # 容量：表示的是顺序表的最大存储量
        self.data = [None] * self.capacity  # 顺序表的空间
        self.size = 0                       # 长度：表示的是顺序表的实际存储量
```
#### 更改顺序表容量
```python
def resize(self,newcapacity):               
    assert newcapacity >= 0                 # 断言，判断参数合法性
    olddata = self.data                     # 保存原数据
    self.data = newcapacity * [None]        # 重新分配空间
    self.capacity = newcapacity             # 更改为新的容量
    for i in range(self.size):              # 重新赋值，还原数据
        self.data[i] = olddata[i]
```
#### 扩容顺序表
```python
def createList(self,a):
    for i in range(len(a)):                 # 设置长度为a的长度
        if self.size == self.capacity:      # 如果顺序表的实际长度和容量相同(上溢出)，就该扩充容量了
            self.resize(2 * self.capacity)  # 扩充容量为原来的2倍
        self.data[self.size] = a[i]         # 将元素a[i]放入顺序表的末尾
        self.size += 1                      # 每放一个元素就增加一个实际容量
```
#### 顺序表尾部插入一个数据
```python
def append(self,a):
    if self.size == self.capacity:          # 如果最大容量不够就扩容
        self.resize(2 * self.capacity)      # 扩容2倍
    self.data[self.size] = a                # 将元素a放入顺序表尾部
    self.size += 1                          # 增加实际容量
```
#### 显示所有数据
```python
def display(self):
    for i in range(self.size):              # 遍历顺序表
        print(self.data[i],end=" ")         # 不换行打印
    print()                                 # 遍历完成后换行
```
#### 获取表长度
```python
def legnth(self):
    retrun self.size                        # 直接返回实际长度size
```
#### 通过索引值查找数据
```python
def getIndex(self,i):
    assert 0 <= i <= self.size              # 断言，判断索引是否合法
    print(f"{i}个元素{self.data[i]}")       # 打印
```
#### 更改索引值的数据
```python
def setIndex(self,i,x):
    assert 0 <= i <= self.size              # 断言，判断索引是否合法
    self.data[i] = x                        # 直接更改
```
#### 通过元素找索引
```python
def getElement(self,x):
    for i in range(self.size):              # 遍历顺序表
        if self.data[i] == x:               # 判断是否找到该元素
            return print(f"元素{x}在{i}位") # 找到了直接return
    print("没有找到元素")                   # 没有return则表示没有找到
```
#### 在索引位置插入数据
```python
def Insert(self,i,x):
    assert 0 <= i <= self.size              # 断言，判断索引是否合法
    if self.size == self.capacity:          # 如果最大容量不够就扩容 
        self.resize(2 * self.capacity)      # 扩容2倍
    for j in range(self.size,i-1,-1):       # 从后往前遍历到第i个元素(腾位置)
        self.data[j+1] = self.data[j]       # 将第i个元素及后面元素往后移位
    self.data[i] = x                        # 将要插入的x赋值给第i个元素
    self.size += 1                          # 增加实际容量
```
#### 删除索引位置数据
```python
def delete(self,i):
    assert 0 <= i < self.size               # 断言，判断参数合法性
    for j in range(i+1,self.size):          # 从第i+1个元素遍历到末尾
        self.data[j-1] = self.data[j]       # 将第i+1个及后面所有元素往前移1位
    self.size -= 1                          # 减少实际容量
```
#### 删除索引从i到k的元素
```python
def delFromTo(self,i,k): 
    assert i >= 0 and k >= 1 and 1<= i+k <= self.size   # 断言，判断参数合法性
    for j in range(i+k,self.size):          # 从第i+k个元素遍历到末尾
        self.data[j-k] = self.data[j]       # 将第i+k个及后面所有元素往前移k位
    self.size -= k                          # 减少实际容量
```
#### 删除表中所有的指定元素
```python
def delSomeone(self,x):
    count = 0                               # 记录有多少个元素被删除
    for i in range(self.size):              # 遍历顺序表
        if self.data[i] == x:               # 如果找到这个元素
            count += 1                      # 增加一个元素的计数
        else:                               # 如果没有找到
            self.data[i-count] = self.data[i]   # 把当前元素往前移动i-(指定元素发现的个数个位置)
    self.size -= count                      # 遍历完成后按照找到的个数对实际容量进行更改
```
#### 合并A、B两个正序表为C，并正序排列C
```python
def mergeSort(self,B):
    C = SqlList()                           # 创建一个新的顺序表
    i = j = 0                               # 初始化两个指针，分别用于遍历A和B
    while i<self.size and j<B.size:         # 两个表都还有元素时
        if self.data[i] <= B.data[j]:       # 比较两个表当前元素的大小
            C.append(self.data[i])          # 将较小的元素放入C
            i += 1                          # 移动指针
        else:
            C.append(B.data[j])
            j += 1
    while i<self.size:                      # 如果A没有遍历完
        C.append(self.data[i])              # 就直接把A尾插入C
        i += 1
    while j<B.size:                         # B同理
        C.append(B.data[j])
        j += 1
    C.display()                             # 展示C
```